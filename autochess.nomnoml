# Individual Compulsory

# For this assignment, you will model a Board Game using UML Class diagrams, in order to best understand how all the elements are interconnected.
# It does not need to be 100% complete or perfect. A reflection report will also be part of the submission (no max or min number of words), where you
# discuss which aspect of implementing a board gave you find most interesting, and which most challenging.

# Submission: Zip file name Last Name_First Name_ Compulsory 1

#PDF or PNG (high quality) with UML class diagrams.
#PDF with self reflection (most interesting AND most challenging aspect to implement).

#ideas: Make a stack for the menu etc. Look at the book data structures for games. Be inspired and have fun!
# Have AI stuff in there! Pathfinding! Min-Max algorithm. Commands! Design patterns!
# Redo, undo, the discard pile
# Look at json
[Game Application|
[
  <<Abstract class>>
  Scene]<-[SplashScreen]
  [
  <<Abstract class>>
  Scene]<-[MainMenu]
  [
  <<Abstract class>>
  Scene
  |
  +id : unsigned int
  
  +components : Array<Component>
  |
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhyics() : virtual void
  ]<-
  [Autochess|
  -Players : Array<Player>

  -Replay : Queue<Command>

  -GameBoard : Board
  
  +NextTurnSound : AudioClip
  
  -BackgroundMusic : AudioClip
  |
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhysics() : virtual void
  ]o-
  [Board |
  +BG : Background
  
  +Grid : Tree<Tile>
  
  +GetMoves : Array<Move>
  |
  -CalculateWeightsForA-Star() : void
  
  -CalculatePerpendicularWeightsForA-Star() : void
  
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void]o-
  [SplashScreen|
  
  -BackgroundDemoGame : Board

  -MenuOptions : Menu
  | 
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhysics() : virtual void
  ]o-[Menu]
  [Board]o-[Tile |
  +Type : EnumTile (empty, unit1, unit2, ...)
  
  +Weight : Integer
  |
  ]
  [Board]o-[Background |
  +front : Bitmap
  
  +back : Bitmap
  
  +top : Bitmap
  
  +bottom : bitmap
  
  +left : bitmap
  
  +right : bitmap
  |
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void
  ]
 [Shop]o-[Piece]
 [Move]o-[Piece]
  [Autochess]o-[Player |
  +Pieces : Array<Piece>
  
  +Score : Integer
  
  +Gold : Integer
  
  +Colour : Integer
  
  +Avatar : Bitmap
  
  +isComputer : Boolean
  |
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhysics() : virtual void
  ]
  [Autochess]o-[Shop |
  +PossiblePieces : Array<Piece>
  
  +Pieces : LinkedList<Piece>
  
  +WildcardPiece : Stack<Piece>
  
  +ShopFront : Bitmap
  |
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void
  ]
  [Player]o-
  [Piece |
  +Name : String
  
  +Icon : Bitmap
  
  +Description : String
  
  +Price : Integer
  
  +Nobility : Integer
  
  +Range : Integer
  
  +3DModelIdle : Mesh
  
  +3DModelAttack : Mesh
  
  +3DModelDie : Mesh
  
  +FoostepSound : AudioClip
  
  +AttackSound : AudioClip
  
  +DieSound : AudioClip
  
  +isFlying : Boolean
  
  +isActive : Boolean
  
  +MovePattern : Array<Vector2D>
  
  +Weights : Array<Vector2D>
  |
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void
  
  +PossibleMoves : Array<Move>
  
  +WalingAnimation : Animation
  ]
  
  [Piece]o-[Animation|
  +StartPosition : Vector2D
  
  +EndPosition : Vector2D
  
  +AnimationMesh : Mesh
  
  +AStarPath : Queue<Vector2D>
  |
  -CalculatePathA-Star() : void
  
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void]
  
  [MainMenu|
  
  -MenuOptions : Stack<Menu>
  
  -StartMenu : Menu
  
  -LoadMenu : Menu
  
  -AudioMenu : Menu
  |
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhysics() : virutal void
  ]o-
  [Menu|
  +Options : Array<MenuItem>
  |
  ]o-[MenuItem]
  
  [MenuItem||+Update() : void]
  [Button|
  
  +TextBackground : Bitmap
  
  +OptionText : String
  
  +ClickedSoundEffect : AudioClip
  
  +HoverSoundEffect : AudioClip
  |
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void
  ]->[MenuItem]
  [Text|
  +Text : String
  |
  +Init() : void
  
  +Update() : void
  
  +UpdateAfterPhysics() : void
  ]->[MenuItem]
  [Autochess]o-
  [Command |
  -NewMove : Move
  
  -OldMove : Move
  |
  +Execute() : void
  
  +Redo() : void
  
  +Undo() : void
  ]o-
  [Move |
  +MovedPiece : Piece*
  
  +Position : Vector2D
  |
  ]
  
  [Minimax]-o[AIPlayer]
  [AIPlayer|-AIController : Minimax|
  +Init() : virtual void
  
  +Update() : virtual void
  
  +UpdateAfterPhysics() : virtual void
  ]->[Player]
  [Minimax|
  +MovesTree : Tree<Move>
  |
  -FindBestMove() : Move
  ]o-[Move]
]

[Game Application]+-[Game Engine|
[NullAudio]<-[PortaudioAudio|
|
+Init() : virtual bool
 
+Shutdown() : virtual bool
 
+Stop() : virtual void
 
+PlaySound(sound : const char*) : virtual void
 
+Update() : virtual void
]
[
<<Abstract class>>
Audio]<-[NullAudio|
|
+Init() : virtual bool
 
+Shutdown() : virtual bool
 
+Stop() : virtual void

+PlaySound(sound : const char*) : virtual void
 
+Update() : virtual void
]
[
<<Abstract class>>
Audio|
|
+Init() : virtual bool
 
+Shutdown() : virtual bool
 
+Stop() : virtual void
 
+PlaySound(sound : const char*) : virtual void
 
+Update() : virtual void
]
[
<<Abstract class>> Filesystem|
|
+Init() : virtual bool
 
+Shutdown() : virtual bool
 
+Open(url : URL, fileType=DATA : const unsigned int) : virtual IFile *
]
[
<<Abstract class>> Filesystem]<-[NullFilesystem|
|
+Init() : virtual bool
 
+Shutdown() : virtual bool
 
+Open(url : URL, fileType=DATA : const unsigned int) : virtual NullFile *
]
[NullFilesystem]<-[StdFilesystem|
|
+Shutdown() : bool
 
+Open(path : URL, dataType=DATA : const unsigned int) : StdFile *
]

[Input
|
+Key : EnumKeyMap

+Mouse : MouseStruct
|
+Define(controlName : const String &, key : unsigned int) : void

+Update() : void

+Held(key : const unsigned Integer) : Boolean

+Held(controlName : String) : Boolean
 
+Pressed(key : const unsigned Integer) : Boolean

+Pressed(controlName : String) : Boolean

+Released(key : const unsigned Integer) : Boolean
 
+Released(controlName : String) : Boolean
 
+OnButton(button : const unsigned Integer, isDown : const Boolean) : void
]o-[MouseStruct|
+x : Integer

+y : Integer

+deltaX : Integer

+deltaY : Integer

+Up : Boolean

+Down : Boolean

+Pressed : Boolean

+Released : Boolean

+Hidden : Boolean

+Dragging : Boolean|]

[
<<Abstract class>> Physics
|
|
+Collide(hitbox=NULL : HitBox*, type="solid" : const char*) : virtual Collider*
 
+Intersect(ray : const Ray&, hitbox : const HitBox*) : virtual bool
 
+CreateHitBox(dimensions : glm::vec3, matrix : Mat*, type="solid" : const char*) : virtual HitBox*
 
+RemoveHitBox(hitbox : HitBox*) : virtual void

+Update () : virtual void
]

[
<<Abstract class>> Physics]<-[NullPhysics]

[NullPhysics]<-[BulletPhysics
|
|
+Update() : void
]

[
BouncePhysics]--[There are a host of fast intersection algorithms at https://www.realtimerendering.com/intersections.html.]

[NullPhysics
|
|
+Intersect(r : const Ray&, hitbox : const HitBox*) : Boolean
 
+Collide(hitbox : HitBox*, type="Box Collidable" : const char*) : Collider*
 
+CreateHitBox(dimensions : glm::vec3, matrix : Mat*, type : const char*) : HitBox*
 
+RemoveHitBox(hitbox : HitBox*) : void
 
+Update() : void
]<-[BouncePhysics
|
\#colliders : Array< Ptr< IPhysics::Collider * > >
|
+Intersect (r : const Ray&, hitbox : const HitBox*) : Boolean

+Collide (hitbox=NULL : HitBox*, type="solid" : const char*) : Collider*
 
+CreateHitBox (dimensions : glm::vec3, matrix : Mat*, type : const char*) : HitBox *
 
+Update() : void
]

[
<<Abstract class>> Physics]o-[Collider
|
+collisions : Array< HitBox * >
 
+direction : glm::vec3
 
+hitbox : HitBox*
|
]o-[HitBox]

[
<<Abstract class>> Physics]o-[HitBox
|
+type : const char*
 
+dimensions : glm::vec3
 
+position : glm::vec3*
 
+oldPosition : glm::vec3
|
]

[
<<Abstract class>> Physics]o-[Ray
|
+origin : glm::vec3
 
+dir : glm::vec3
 
+invdir : glm::vec3
 
+sign : Array<Integer>
|
]

[
<<Abstract class>> Renderer
|
+windowWidth : Integer
 
+windowHeight : Integer
 
+framebufferdata : Integer*
|
\#PreRender() : virtual void
 
\#PostRender() : virtual void

+Init(fullscreen : Boolean, windowTitle: const char*, windowLength : const unsigned int, windowHeight : const unsigned int) : virtual Boolean
 
+Render(projViewMatrixArray : const Array< glm::mat4 >&, viewBoundsArray : const Array< glm::vec4 >&) : virtual void
 
+DrawDebugText(x : float, y : float, str : const char*) : virtual void
 
+Resize(length : Integer, height : Integer) : virtual void
 
+CreateDrawable(vertices : Array< IDrawable::Vertex >&, indices : Array< unsigned int >&, shaders : Array< String >&, textures=Array< ITexture * >() : Array< ITexture * >) : virtual IDrawable *
 
+CeateDrawable(vertices : Array< IDrawable::Vertex >&, indices : Array< unsigned int >&, shaders : Array< String >&, texture : ITexture*) : virtual IDrawable*

+RemoveDrawable(drawable : IDrawable*) : virtual void
 
+CreateTexture(filename : String) : virtual ITexture*
 
+CreateTexture(front : String, back : String, top : String, bottom : String, left : String, right : String) : virtual ITexture*
 
+CreateTexture(width : Integer, height : Integer) : virtual ITexture*
 
+RemoveTexture(texture : ITexture*) : virtual void
 
+SetDirectionalLight(direction : glm::vec3, light : ILight*) : virtual void
 
+ResetDirectionalLight() : virtual void
 
+AddPointLight(position : glm::vec3, quadricEquation : glm::vec3, light : ILight*) : virtual ILight *
 
+RemovePointLight(light : ILight*) : virtual void
 
+CreateCamera(viewport : Integer, position : glm::vec3, orientation : glm::vec3) : virtual ICamera*
 
+RemoveCamera (camera : ICamera*) : virtual void
 
+Draw (drawable : IDrawable*) : virtual void
]
[NullRenderer]<-[DX11Renderer]
[
NullRenderer]<-[GLES2Renderer]
[
<<Abstract class>> Renderer]<-[NullRenderer]

[Containers|
[LinkedList]
[Array]
[Tree]
[Queue]
[Stack]
]

]

# [<table>mischief| bawl | sing || yell | drink ]
# [<start>start] -> [<state>plunder] -> [<choice>more loot] -> [start]
# [more loot] no ->[<end>e]
# [<abstract>Marauder]<:--[Pirate]
# [Pirate] - 0..7[mischief]
# [<actor id=sailor>Jolly;Sailor]
# [sailor]->[Pirate]
# [sailor]->[rum]
# [Pirate]-> *[rum|tastiness: Int|swig()]


#[Dwarves: Gem Chase is a board game for two to six players.
#The game takes place on a mountain where greedy dwarves fight to become the wealthiest dwarf of them all.
#The mountain is scattered with gemstones of great value, and a golden dragon egg at the very tip of the mountain.
#All gemstones are placed on the map and picked up during the game.
#
#At the beginning of the game, each player chooses a color and a corner to be their home base and places their coloured player pieces (dwarves) there.
#They will also receive a secret mission card. Players take turns moving their game pieces and collecting gemstones.
#If the dragon egg is collected and brought back to a dwarf's home base, the game ends.
#To pick up the dragon egg, a player must first possess a minimum of three gemstones.
#If all the gemstones are picked up, the game ends. The game also ends if a player completes their secret mission.
#
#The winner is the player with the most gemstones when the game ends, alternatively the player who has completed their secret mission.
#
#END STATES: 
#* Dragon egg has been taken to a home base.
#* A player completes their secret mission.
#* All gems gone from the game board.
#
#VICTORY: 
#* The winner is the player with the most gems in their home base.
#* Alternatively, the player who finishes their mission is the winner.
#* Dragon egg is worth 10 gems if at a player’s home base.
#
#For 2 - 6 players.
#Playtime: 25 min.
#
#Get Started (In this version of the game, the board has already been set up for you)
#
#* Place the gems on the game board where there are gem icons.
#* Put the dragon egg in the middle of the board.
#
#Choose a colour!
#* Take your dwarf pieces and put them in your colour's start ship.
#(In this version, simply choose a colour, you can change your colour by pressing the icon at the top right of the screen)
#
#Let's go.
#Decide on who starts by rolling a die! Player with the highest number starts.
#
#The game goes in turns clockwise.
#
#Before you begin ...
#* Each player takes a mission card from the mission card pile. (Remember to shuffle the cards! Keep your mission secret)
#
#Start your turn
#* You receive 4 action points at the beginning of each turn.
#* To use a card on your hand costs 1 action point.
#* To move one of your dwarves costs 1 action point per space.
#* When moving out of your ship, the first space is marked ① .
#* You can only move your dwarves in the direction marked on the map.
#* Your dwarves may share the same space on the game board.
#* If you move to a place with gems, you can use 1 action point per gem to pick them up! Put the gems into your ship.
#* When one of your dwarves reaches a yellow area you can pick up a chance card FOR FREE! (Only one chance card can be picked up per turn)
#* Only players with three gems (of any colour) in their ship can pick up the dragon egg - pick up and carry the dragon egg with
#a dwarf by moving a dwarf over to it and placing the egg onto the dwarves' open arms. Picking up the dragon egg does not cost any action points.
#While carrying the dragon egg, movement is limited to two spaces for that dwarf (Remember, you can still move other dwarf pieces and use cards
#for the remaining action points) The game ends when a player has taken the dragon egg all the way to their Home Base, the egg is worth 10 gems 
#but the winner might still be the one with the most gems.
#* A dwarf landing on another team's dwarf sends the enemy dwarf back to their home base and you can steal one gem for 0 action points from the other player.
#* By landing on a dwarf holding the dragon egg, you can choose to simply send the enemy dwarf back to their home base, or to also take the dragon egg
#with you, carried by your dwarf, if you have at least 3 gems (of any colour) in your gem store.
#
#Always remember:
#* The dragon egg is worth 10 gems. It has to be in your home base to count towards your score.
#* A dwarf carrying the dragon egg can only move two spaces per turn.
#* You receive a chance card FOR FREE by passing yellow spaces with a dwarf. Only one per turn."]




